<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-101</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Iniciando variáveis

//Física
grav = 0.2; // gravidade
hsp = 0; // velocidade horizontal
hsp_carry = 0; // velocidade horizontal aplicada quando o personagem está sobre uma plataforma móvel
vsp = 0; // velocidade vertical
number_jump = 0; //contador de pulos, variável de controle
number_jump_max = 2; //limite máximo de pulos


//Booleanos
ball = 0; //booleano para a bolinha
block = 0; //booleano para a defesa
cheat = 0; //booleano para o cheat
spr_jump = 0; //variável auxiliar para a animação do pulo duplo
spr_wall_jump = 0; //variável auxiliar para a animação do pulo na parede
count_step = 15; // variável auxiliar para o som dos passos
fly_enabled = 0; //variável auxiliar para habilitação do cheat


//Power-Up (não implementado)
movespeed_normal = 4; // velocidade de movimento normal
movespeed_powerup = 7; // velocidade de movimento normal
movespeed = movespeed_normal; // inicia o personagem com velocidade de movimento normal

jumpspeed_normal = 7; // velocidade do pulo normal
jumpspeed_powerup = 10; // velocidade do pulo com o powerup
jumpspeed = jumpspeed_normal //inicia o personagem com velocidade de pulo normal

//controle de checkpoint
if(global.checkpointR == room)// checa se o personagem já passou por um checkpoint na sala atual
{
    // define o checkpoint ativo como novo local de renascimento
    x = global.checkpointx;
    y = global.checkpointy;
}

key_down = 0; // booleano ativo pela tecla "seta para baixo"

double_jump_key = 0; //booleano que ativa o poder do pulo duplo

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Voltando ao normal após o tempo do powerup expirar
jumpspeed = jumpspeed_normal;
movespeed = movespeed_normal;
sprite_index = spr_player;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Checagens gerais
// Trabalhando com as inserções do jogador
key_right = keyboard_check(vk_right); // seta para a direita
key_left = keyboard_check(vk_left); // seta para a esquerda
key_jump = keyboard_check_pressed(vk_space); // tecla "espaço"
key_down = keyboard_check(vk_down); // seta para baixo
key_up = keyboard_check(vk_up); //seta pra cima
key_cheat = keyboard_check_pressed(ord('F'));//cheat
key_ball = keyboard_check_pressed(ord('X')); //tecla x
key_block = keyboard_check_pressed(ord('Z')); //tecla z
key_stop_music = keyboard_check_pressed(ord('M')); //para a música

// Calculando Movimento
var move = key_right - key_left; // controle da direção horizontal do personagem.
var move_cheat = key_down - key_up; //controle da direção vertical do personagem. Uso apenas no cheat.
hsp = move * movespeed; // adicionando velocidade a direção do personagem.
if(cheat){
vsp = move_cheat;
}else if(vsp &lt;10) vsp += grav; // adicionando gravidade até certo ponto ao personagem.

// Pulo Duplo
if (sprite_index != spr_player_ball){//testa se está na forma de bola, caso esteja, não pode pular

    if (double_jump_key) number_jump_max = 2; else number_jump_max = 1; // testa se a habilidade do pulo duplo está ativada
    
    if(place_meeting( x, y + 1, obj_wall)) // teste de colisão com o objeto parede (obj_wall).
    {
        number_jump = number_jump_max; // zera a contagem de pulos    
    }
    if (key_jump) &amp;&amp; (number_jump &gt; 0) // teste para a execução do pulo
    {   
        if(number_jump == 1) &amp;&amp; (double_jump_key) spr_jump = 15; //ativa uma variável que será utilizada na animação do pulo duplo
        number_jump -= 1; // diminui a contagem de pulos em 1
        audio_play_sound(snd_jump,0,0);//som do pulo
        vsp =  -jumpspeed; // quando há colisão vertical, esse trecho ocorre e a vel. 
        // vertical zera e só é alterada pelo pulo, eles está negativo porque a contagem de 
        // pixels é de cima pra baixo, e o pulo joga o personagem pra cima.
    }
}

// Pulo na Parede
if (key_left) &amp;&amp; (key_jump) &amp;&amp; (place_meeting(x+1,y,obj_wall)) &amp;&amp; (!place_meeting(x,y+1,obj_wall)) // checagem para pulo na parede à esquerda
{
    spr_wall_jump = 15; //ativa uma variável que será utilizada na animação do pulo na parede
    audio_play_sound(snd_wall_jump,0,0); //som do pulo na parede
    vsp = -jumpspeed; 
}
if (key_right) &amp;&amp; (key_jump) &amp;&amp; (place_meeting(x-1,y,obj_wall)) &amp;&amp; (!place_meeting(x,y+1,obj_wall)) // checagem para pulo na parede à esquerda
{
    spr_wall_jump = 15; //ativa uma variável que será utilizada na animação do pulo na parede
    audio_play_sound(snd_wall_jump,0,0); //som do pulo na parede
    vsp = -jumpspeed;
}

var hsp_final = hsp + hsp_carry; //adiciona a velocidade da plataforma móvel, se o personagem estiver sobre uma
hsp_carry = 0; //zera a velocidade extra, após essa ter sido incrementada

//Habilitando cheat
if keyboard_check_pressed(ord('H')){
    enable_cheat = get_string("Digite o cheat que deseja habilitar abaixo","");
    if (enable_cheat == "fly"){
        fly_enabled = 1;
    }    
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Animação
spr_jump--;//decrementa a variável auxilar do pulo duplo
spr_wall_jump--; //decrementa a variável auxilar do na parede



if(key_cheat) &amp;&amp; (fly_enabled){
    if(cheat == 0) &amp;&amp; (!place_meeting( x, y - 25, obj_wall)){
    audio_play_sound(snd_helicopter,0,1);//som de helicóptero enquanto está voando
    cheat = 1; ball = 0; block = 0; //deixa apenas um dos booleanos ativados
    }else{
    audio_stop_sound(snd_helicopter); //cancela o som de helicóptero
    cheat = 0;
    }
}
if(key_ball){ //condicional que altera o booleano responsável pela mecânica da bolinha
    if (ball == 0) &amp;&amp; (place_meeting(x,y+1,obj_wall)){
    audio_play_sound(snd_ball,0,0); //som ao virar bolinha
    audio_stop_sound(snd_helicopter); //cancela o som de helicóptero
    cheat = 0; ball = 1; block = 0; //deixa apenas um dos booleanos ativado
    } else if (!place_meeting( x, y - 25, obj_wall)) { //testa se, enquanto está na forma de bolinha, existe alguma obstrução acima. Também testa se está no ar
    ball = 0;
    }
}
if(key_block){ //condicional que altera o booleano responsável pela mecânica da defesa
    if (block == 0) &amp;&amp; (!place_meeting( x, y - 25, obj_wall)) &amp;&amp; (place_meeting(x,y+1,obj_wall)){ //testa se, enquanto está na forma de bolinha, existe alguma obstrução acima. Também testa se está no ar
    audio_play_sound(snd_block,0,0);//som ao usar bloqueio
    audio_stop_sound(snd_helicopter); //cancela o som de helicóptero
    cheat = 0; block = 1; ball = 0; //deixa apenas um dos booleanos ativado
    } else {
    block = 0;
    }
}
if(place_meeting(x,y+1,obj_wall)) //transformações possíveis quando se está no chão
{
    if(cheat){
        grav = 0.05;
        sprite_index = spr_player_cheat;//trnasforma no sprite voador (cheat)
    }else{
        grav = 0.2;
        if (ball){
        sprite_index = spr_player_ball; //transforma no sprite da bolinha
    }else if (block) &amp;&amp; (hsp == 0){
        sprite_index = spr_player_block; //transforma no sprite de defesa
    }else{
        if (hsp != 0){
            sprite_index = spr_player_run; //transforma no sprite parado
            block = 0;
        }else{
            sprite_index = spr_player; //transforma no sprite de corrida
            }
        }  
    }      
}else{ //transformações possíveis quando não se está no chão
    if(ball){
        sprite_index = spr_player_ball; //mantém a forma de bolinha enquanto está caindo
    }
    else if(!cheat){
        grav = 0.2;
        if(spr_jump &gt; 0)
        {
            sprite_index = spr_player_2jump; //transforma no sprite de pulo duplo
        }else if (spr_wall_jump &gt; 0){
            sprite_index = spr_player_wall_jump; //transforma no sprite de pulo na parede
        }else{
            sprite_index = spr_player_jump; //transforma no sprite de pulo
        if (sign(vsp) &gt; 0) sprite_index = spr_player_fall; //transforma no sprite de queda
        } 
    }else{
        grav = 0;
        sprite_index = spr_player_cheat;//pramsforma no sprite do cheat (helicóptero)
    }       
}   
if (move!=0) image_xscale = move; //inverte a imagem de acordo com a direção horizontal

//Parallax
background_x[3] = view_xview/1.2;
background_x[2] = view_xview/1.3;
background_x[1] = view_xview/1.4;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Colisões
// Colisão horizontal
if (place_meeting(x+hsp_final,y ,obj_wall)) // teste de colisão com o objeto parede (obj_wall).
{
    while(!place_meeting(x + sign(hsp_final),y ,obj_wall)) // "while" gera um loop que só para quando a sua afirmação for falsa,
    // a função "sign(hsp)" é uma indicadora que retorna o sentido da variável mult. por 1.
    {
    x += sign(hsp_final); // joga o personagem 1 pixel na direção que está seguindo
    }
    hsp_final = 0; // zera a movimentação horizontal
    hsp = 0;
   // number_jump = 0;
} 
x += hsp_final; // movimenta o personagem na direção desejada

// Colisão vertical (idêntica a colisão horizontal, mudando apenas algumas variáveis)
if (place_meeting(x ,y + vsp,obj_wall)) // teste de colisão com o objeto parede (obj_wall).
{
    while(!place_meeting(x ,y + sign(vsp),obj_wall)) // while gera um loop que só para quando a sua afirmação for falsa,
    // a função sign(hsp) é uma indicadora que retorna o sentido da variável mult. por 1.
    {
    y += sign(vsp) // joga o personagem 1 pixel na direção que está seguindo
    }
    vsp = 0 // zera a movimentação vertical
} 

y += vsp; // movimenta o personagem na direção desejada

//Colisão com a bala
if(place_meeting(x,y,obj_red_bullet))||(place_meeting(x,y,obj_blue_bullet)){ //se o personagem for atingido por uma bala
    if(block == 0){ //caso não esteja se defendendo, opersonagem morre
        scr_death();
    }else{
        audio_play_sound(snd_block,0,0); //faz o som do bloqueio
    }    
}

// "Colisão" com o abismo
if (place_meeting(x,y,obj_cliff)) // testa se há contato com o personagem
{
   scr_death();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sons
//Som dos passos
if (count_step!=0){ //condicional para contrloar o espaçamento entre osom dos passos
    count_step--; //decremento da variável de controle
}else{
    if(sprite_index = spr_player_run){ //teste para continuar executando o som dos passos
        audio_play_sound(snd_step_player,0,0); //som dos passos
    }
    count_step = 15; //número determinístico para o espaçamento dos passos
}

//Aterrisando
if (vsp &gt; 0) &amp;&amp; (sprite_index = spr_player_fall) &amp;&amp; (place_meeting(x ,y + 1 ,obj_wall)){ //testa se o personagemcaindo, chega ao solo
    audio_play_sound(snd_land,0,0); //som da aterrissagem
}

if(key_stop_music){ //para a música da fase
    audio_stop_sound(snd_ost_fase1_parte_1_2);
    audio_stop_sound(snd_ost_fase1_parte_3);
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Caso o personagem saia da tela
audio_stop_sound(snd_helicopter);
scr_death();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="82">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Reinicia o jogo

game_restart(); // reinicia o jogo
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
